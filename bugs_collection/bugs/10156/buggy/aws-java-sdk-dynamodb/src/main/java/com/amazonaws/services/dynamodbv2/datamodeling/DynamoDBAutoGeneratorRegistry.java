/*
 * Copyright 2010-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *  http://aws.amazon.com/apache2.0
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.dynamodbv2.datamodeling;

import java.lang.annotation.Annotation;
import java.math.BigInteger;
import java.util.Calendar;
import java.util.Date;
import java.util.Map;
import java.util.TimeZone;
import java.util.UUID;

import com.amazonaws.annotation.SdkInternalApi;

/**
 * Helper for auto-generating attribute values.
 */
@SdkInternalApi
final class DynamoDBAutoGeneratorRegistry {

    /**
     * The default instance.
     */
    private static final DynamoDBAutoGeneratorRegistry INSTANCE = new DynamoDBAutoGeneratorRegistry();

    /**
     * Gets the default instance.
     * @return The default instance.
     */
    static final DynamoDBAutoGeneratorRegistry instance() {
        return INSTANCE;
    }

    /**
     * Gets the never generator given the annotation and generatedType.
     * @param generatedType The generated type class.
     * @param annotation The annotation instance.
     * @return The generator.
     */
    static final Generator<Object> generatorOf(final Class<?> generatedType, final Map<Class<? extends Annotation>,Annotation> annotations) {
        if (annotations.containsKey(DynamoDBAutoGeneratedKey.class)) {
            return instance().keyGeneratorOf(generatedType);
        } else if (annotations.containsKey(DynamoDBVersionAttribute.class)) {
            return instance().versionGeneratorOf(generatedType);
        } else if (annotations.containsKey(DynamoDBAutoGeneratedTimestamp.class)) {
            final DynamoDBAutoGeneratedTimestamp annotation = (DynamoDBAutoGeneratedTimestamp)annotations.get(DynamoDBAutoGeneratedTimestamp.class);
            return instance().timestampGeneratorOf(generatedType, annotation.strategy());
        } else {
            return instance().neverGeneratorOf(generatedType);
        }
    }

    /**
     * Gets the never generator given the annotation and generatedType.
     * @param generatedType The generated type class.
     * @return The generator.
     */
    final Generator<Object> neverGeneratorOf(final Class<?> generatedType) {
        final Generator<? extends Object> result = new NeverGenerator(generatedType);
        return (Generator<Object>)result;
    }

    /**
     * Gets the key generator given the annotation and generatedType.
     * @param generatedType The generated type class.
     * @return The generator.
     */
    final Generator<Object> keyGeneratorOf(final Class<?> generatedType) {
        final Generator<? extends Object> result;
        if (String.class.isAssignableFrom(generatedType)) {
            result = UuidStringKeyGenerator.INSTANCE;
        } else {
            result = new NeverKeyGenerator(generatedType);
        }
        return (Generator<Object>)result;
    }

    /**
     * Gets the version generator given the annotation and generatedType.
     * @param generatedType The generated type class.
     * @return The generator.
     */
    final Generator<Object> versionGeneratorOf(final Class<?> generatedType) {
        final Generator<? extends Object> result;
        if (BigInteger.class.isAssignableFrom(generatedType)) {
            result = BigIntegerVersionGenerator.INSTANCE;
        } else if (Byte.class.isAssignableFrom(generatedType) || byte.class.isAssignableFrom(generatedType)) {
            result = ByteVersionGenerator.INSTANCE;
        } else if (Integer.class.isAssignableFrom(generatedType) || int.class.isAssignableFrom(generatedType)) {
            result = IntegerVersionGenerator.INSTANCE;
        } else if (Long.class.isAssignableFrom(generatedType) || long.class.isAssignableFrom(generatedType)) {
            result = LongVersionGenerator.INSTANCE;
        } else if (Short.class.isAssignableFrom(generatedType) || short.class.isAssignableFrom(generatedType)) {
            result = ShortVersionGenerator.INSTANCE;
        } else {
            result = new NeverVersionGenerator(generatedType);
        }
        return (Generator<Object>)result;
    }

    /**
     * Gets the timestamp generator given the annotation and generatedType.
     * @param generatedType The generated type class.
     * @param strategy The auto-generation strategy.
     * @return The generator.
     */
    final Generator<Object> timestampGeneratorOf(final Class<?> generatedType, final DynamoDBAutoGenerateStrategy strategy) {
        final Generator<? extends Object> result;
        if (Calendar.class.isAssignableFrom(generatedType)) {
            result = new CalendarTimestampGenerator(strategy);
        } else if (Date.class.isAssignableFrom(generatedType)) {
            result = new DateTimestampGenerator(strategy);
        } else if (Long.class.isAssignableFrom(generatedType)) {
            result = new LongTimestampGenerator(strategy);
        } else {
            result = new NeverTimestampGenerator(generatedType, strategy);
        }
        return (Generator<Object>)result;
    }

    /**
     * Generator for auto-generating attribute values.
     */
    static interface Generatable<T> {
        /**
         * Determines if the value can be auto-generated for the object.
         * @param currentValue The current attribute value.
         * @return True if can be auto generated, false otherwise.
         */
        abstract public boolean canGenerate(T currentValue);
    }

    /**
     * Default logic for never generatable.
     */
    static final class NeverGeneratable<T> implements Generatable<T> {
        private static final NeverGeneratable<Object> INSTANCE = new NeverGeneratable<Object>();

        @SuppressWarnings("unchecked")
        private static final <T> NeverGeneratable<T> instance() {
            return (NeverGeneratable<T>)INSTANCE;
        }

        @Override
        public final boolean canGenerate(final T currentValue) {
            return false;
        }
    }

    /**
     * Default logic for always generatable.
     */
    static final class AlwaysGeneratable<T> implements Generatable<T> {
        private static final AlwaysGeneratable<Object> INSTANCE = new AlwaysGeneratable<Object>();

        @SuppressWarnings("unchecked")
        private static final <T> AlwaysGeneratable<T> instance() {
            return (AlwaysGeneratable<T>)INSTANCE;
        }

        @Override
        public final boolean canGenerate(final T currentValue) {
            return true;
        }
    }

    /**
     * Default logic for generatable on create only.
     */
    static final class CreateGeneratable<T> implements Generatable<T> {
        private static final CreateGeneratable<Object> INSTANCE = new CreateGeneratable<Object>();

        @SuppressWarnings("unchecked")
        private static final <T> CreateGeneratable<T> instance() {
            return (CreateGeneratable<T>)INSTANCE;
        }

        @Override
        public final boolean canGenerate(final T currentValue) {
            return (currentValue == null);
        }
    }

    /**
     * Generator for auto-generating attribute values.
     */
    static interface Generator<T> extends Generatable<T> {
        /**
         * Generates a new attribute value for the target object.
         * @param currentValue The current attribute value.
         * @return The new attribute value.
         */
        abstract public T generate(T currentValue);
    }

    /**
     * Abstract generator, does not generate.
     */
    static abstract class AbstractGenerator<T> implements Generator<T> {
        private final Class<T> generatedType;
        private final Generatable<T> generatable;

        public AbstractGenerator(final Class<T> generatedType, final Generatable<T> generatable) {
            this.generatedType = generatedType;
            this.generatable = generatable;
        }

        public AbstractGenerator(final Class<T> generatedType, final DynamoDBAutoGenerateStrategy strategy) {
            this(generatedType, (DynamoDBAutoGenerateStrategy.CREATE == strategy ? CreateGeneratable.<T>instance() : AlwaysGeneratable.<T>instance()));
        }

        private final Class<T> getGeneratedType() {
            return this.generatedType;
        }

        private final Generatable<T> getGeneratable() {
            return this.generatable;
        }

        @Override
        public boolean canGenerate(final T currentValue) {
            return getGeneratable().canGenerate(currentValue);
        }

        @Override
        public T generate(final T currentValue) {
            throw new DynamoDBMappingException("Generate not supported for " + getGeneratedType());
        }
    }

    /**
     * Never generator for key.
     */
    static class NeverGenerator<T> extends AbstractGenerator<T> {
        public NeverGenerator(final Class<T> generatedType) {
            super(generatedType, NeverGeneratable.<T>instance());
        }
    }

    /**
     * Never generator for key.
     */
    static class NeverKeyGenerator<T> extends AbstractGenerator<T> {
        public NeverKeyGenerator(final Class<T> generatedType) {
            super(generatedType, CreateGeneratable.<T>instance());
        }

        @Override
        public T generate(final T currentValue) {
            throw new DynamoDBMappingException("Unsupported type for @DynamoDBAutoGeneratedKey; only String allowed");
        }
    }

    /**
     * Key generator for UUID strings.
     */
    static final class UuidStringKeyGenerator extends NeverKeyGenerator<String> {
        private static final UuidStringKeyGenerator INSTANCE = new UuidStringKeyGenerator();

        public UuidStringKeyGenerator() {
            super(String.class);
        }

        @Override
        public final String generate(final String currentValue) {
            return UUID.randomUUID().toString();
        }
    }

    /**
     * Never generator for version.
     */
    static class NeverVersionGenerator<T> extends AbstractGenerator<T> {
        public NeverVersionGenerator(final Class<T> generatedType) {
            super(generatedType, AlwaysGeneratable.<T>instance());
        }

        @Override
        public T generate(final T currentValue) {
            throw new DynamoDBMappingException("Unsupported type for @DynamoDBVersionAttribute; only BigInteger, Byte, Integer or Long allowed");
        }
    }

    /**
     * Version generator for {@code BigInteger} types.
     */
    static final class BigIntegerVersionGenerator extends NeverVersionGenerator<BigInteger> {
        private static final BigIntegerVersionGenerator INSTANCE = new BigIntegerVersionGenerator();

        public BigIntegerVersionGenerator() {
            super(BigInteger.class);
        }

        @Override
        public final BigInteger generate(final BigInteger currentValue) {
            if (currentValue == null) {
                return BigInteger.ONE;
            }
            return currentValue.add(BigInteger.ONE);
        }
    }

    /**
     * Version generator for {@code Byte} types.
     */
    static final class ByteVersionGenerator extends NeverVersionGenerator<Byte> {
        private static final ByteVersionGenerator INSTANCE = new ByteVersionGenerator();

        public ByteVersionGenerator() {
            super(Byte.class);
        }

        @Override
        public final Byte generate(final Byte currentValue) {
            if (currentValue == null) {
                return Byte.valueOf((byte)1);
            }
            // Mod MAX_VALUE since that's what the DynamoDBReflector used to do.
            return (byte)((currentValue + 1) % Byte.MAX_VALUE);
        }
    }

    /**
     * Version generator for {@code Integer} types.
     */
    static final class IntegerVersionGenerator extends NeverVersionGenerator<Integer> {
        private static final IntegerVersionGenerator INSTANCE = new IntegerVersionGenerator();

        public IntegerVersionGenerator() {
            super(Integer.class);
        }

        @Override
        public final Integer generate(final Integer currentValue) {
            if (currentValue == null) {
                return Integer.valueOf(1);
            }
            return (int)(currentValue + 1);
        }
    }

    /**
     * Version generator for {@code Long} types.
     */
    static final class LongVersionGenerator extends NeverVersionGenerator<Long> {
        private static final LongVersionGenerator INSTANCE = new LongVersionGenerator();

        public LongVersionGenerator() {
            super(Long.class);
        }

        @Override
        public final Long generate(final Long currentValue) {
            if (currentValue == null) {
                return Long.valueOf(1L);
            }
            return (long)(currentValue + 1L);
        }
    }

    /**
     * Version generator for {@code Short} types.
     */
    static final class ShortVersionGenerator extends NeverVersionGenerator<Short> {
        private static final ShortVersionGenerator INSTANCE = new ShortVersionGenerator();

        public ShortVersionGenerator() {
            super(Short.class);
        }

        @Override
        public final Short generate(final Short currentValue) {
            if (currentValue == null) {
                return Short.valueOf((short)1);
            }
            return (short)(currentValue + 1);
        }
    }

    /**
     * Never generator for timestamp.
     */
    static class NeverTimestampGenerator<T> extends AbstractGenerator<T> {
        public NeverTimestampGenerator(final Class<T> generatedType, final DynamoDBAutoGenerateStrategy strategy) {
            super(generatedType, strategy);
        }

        @Override
        public T generate(final T currentValue) {
            throw new DynamoDBMappingException("Unsupported type for @DynamoDBAutoGeneratedTimestamp; only Calendar, Date, or Long allowed");
        }
    }

    /**
     * Timestamp generator for {@code Calendar} types.
     */
    static final class CalendarTimestampGenerator extends NeverTimestampGenerator<Calendar> {
        public CalendarTimestampGenerator(final DynamoDBAutoGenerateStrategy strategy) {
            super(Calendar.class, strategy);
        }

        @Override
        public final Calendar generate(final Calendar currentValue) {
            return Calendar.getInstance();
        }
    }

    /**
     * Timestamp generator for {@code Date} types.
     */
    static final class DateTimestampGenerator extends NeverTimestampGenerator<Date> {
        public DateTimestampGenerator(final DynamoDBAutoGenerateStrategy strategy) {
            super(Date.class, strategy);
        }

        @Override
        public final Date generate(final Date currentValue) {
            return Calendar.getInstance().getTime();
        }
    }

    /**
     * Timestamp generator for {@code Long} types; milliseconds from epoch in UTC.
     */
    static final class LongTimestampGenerator extends NeverTimestampGenerator<Long> {
        private static final TimeZone UTC = TimeZone.getTimeZone("UTC");

        public LongTimestampGenerator(final DynamoDBAutoGenerateStrategy strategy) {
            super(Long.class, strategy);
        }

        @Override
        public final Long generate(final Long currentValue) {
            return Calendar.getInstance(UTC).getTime().getTime();
        }
    }

}
